# 10. 동적 메모리 할당 (alloc)

## 컴파일 타임(Compile Time) 과 런타임(Run Time)

#### 컴파일 타임
* 개발자가 소스 코드를 작성 하는 단계를 의미한다. 
* 컴파일 타임에서는 상수, 명령 실행 순서와 조건 등만 결정이 된다. 
* 코드를 작성하고, 컴파일 까지의 상황을 의미하고, 이떄 발생하는 에러를 컴파일 에러라고 한다. 
* 컴파일 타임 에러는 컴파일러가 문제를 모두 확인해 주기 때문에, 문제 파악이 크게 어렵지 않다.

#### 런타임
* 컴파일이 끝나고 실행 파일이 만들어져서, 실행 파일에 의해서 프로그램이 실행 되고 있는 단계를 의미한다. 
* 실제 실행되는 변수, 조건, 반복등은 런타임에서 결정된다.
* 런타임 상황에서, 소스 코드의 문제로 실행 중간에 에러가 발생 하는 경우 런타임 에러라고 한다. 
	* 일반적으로 프로그램을 사용하면서 발생 하는 문제는 런타임 에러에 해당한다.
* 런타임 에러는 , 정확한 문제 위치와 원인 파악이 쉽지 않아서 해결이 쉽지 않다. 

## 배열 크기 

* 배열의 크기는 처음에 지정해 주어야 한다. 

```
int numbers[5];
```

* 배열을 사용 할때는, 변수를 통해서 index를 관리 할 수 있지만, 최초 선언할 때는 크기를 고정적으로 정해 주어야 한다. 
* 배열의 크기는 **컴파일 타임** 에서 결정이 되어야 한다. 
*  배열의 크기를 명확하게 얼마나 사용 할지 모를떄는, 필요 이상의 메모리를 미리 선언해야 하고 쓰지 않는 메모리를 낭비하게 된다. 
* 만약 배열의 크기를 잘 못 예측하여, 넘칠경우 프로그램이 중단 될 수도 있다. 


## malloc
* 다른 변수 처럼 배열의 크기도 **런타임** 에서 결정 할 수 있다. 
* 단, 배열 문법이 아니라, 새로운 개념으로 접근해서 사용 해야 한다. 
* 런타임에서 배열의 크기를 정한 다는 것은 메모리에 배열로 사용 할 공간을 확보한다는 것을 의미한다. 
* 이를 **동적 메모리 할당** 이라고 한다. 
* 아래와 같이 malloc 함수를 통해서 사용 된다.
* malloc 함수를 사용 하기 위해서는 stdlih.h 를 include 해주어야 한다.  

```
int *numbersPointer = (int *)malloc(20);
numbersPointer[0] = 4;
numbersPointer[1] = 5;
numbersPointer[2] = 3;
numbersPointer[3] = 6;
numbersPointer[4] = 2;
```
* malloc 함수는 사용할 byte 단위의 크기를 파라미터를 받아서 그만큼 공간을 만들어 준다. 
	* 5개의 int 변수를 저장 할 공간이므로 4(int 는 4byte) * 5 인 20을 할당하였다.
* 할당된 공간의 메모리 주소를 return 해주고, 이를 원하는 type 의 포인터 변수에 저장해 주면 된다. 
* 리턴되는 포인터에는 type이 정해져 있지 않기 떄문에, 캐스팅을 통해서 원하는 포인터 타입으로 변환 해주어야 한다. 
* 배열 처럼 바로 초기화할 수는 없지만, 위와 같은 형태로 기존 배열과 같은 방법으로 사용이 가능한다. 

## sizeof
* malloc 을 사용 하기 위해서는 모든 타입의 byte 크기를 알아야 할까?
* 환경(OS) 에 따라서 타입의 크기는 다를 수 있는데, 이렇게 직접 입력해도 괜찮을까?
* 좋지 못하다. 
* 타입에 따라 크기를 알아 낼 수 있는 함수가 존재 한다. 

`int size = sizeof(int);`  

* sizeof 함수는 타입을 파라미터로 받아서 해당 타입이 몇 byte 인지 return 해준다. 
* 아래와 같이 sizeof를 통해서 결과를 출력 해보면 아래와 같다. 

```
printf("%d\n", sizeof(int));
printf("%d\n", sizeof(char));
printf("%d\n", sizeof(long));
printf("%d\n", sizeof(float));
```
> 출력 예시 (실행 환경에 따라서 값이 다르게 출력 될 수 있다

```
4
1
8
4
```

* 이 것을 이용해서 위와 같이 명확한 크기로 malloc을 사용 할 수 있다. 

`int *numbersPointer = (int *)malloc(sizeof(int) * 4);`

*  sizeof 를 통해서 구해진 byte 크기와 원하는 갯수를 곱하여 그 결과 만큼 메모리를 할당 하면 된다. 

## 메모리 해제
* 동적으로 할당된 메모리는 다른 변수들과 다르게 자동으로 메모리를 반환 하지 않는다. 
* 명시적으로 해제 해주지 않으면, 메모리가 계속 사용 되어 낭비 되게 된다. 

`free(numbersPointer);` 

* free 함수를 통해서 간단하게 해제 할 수 있다. 
* 단, free 를 이미 해준 포인터 변수를 다시 해제 하려고 하면 런타임 에러가 발생하고, 프로그램이 중단된다. 

```
int *numbersPointer = (int *)malloc(sizeof(int) * 4);
printf("%p\n", numbersPointer);
    
numbersPointer = (int *)malloc(sizeof(int) * 4);
printf("%p\n", numbersPointer);
```

> 출력 예시 

```
0x1004b6450
0x1004b4a00
```

* 같은 포인터 변수에 동적 메모리 할당을 하게 되더라도, malloc 을 해줄 때 마다, 메모리가 새로 할당 되어 저장되는 주소가 바뀐다.
* 따라서, 포인터 변수를 재 사용 할때, 기존 메모리를 해제 해주지 않으면, 주소를 잃어 버리게 되어 해제 해줄 방법이 없어진다.
* 포인터 변수를 재사용 할때는 꼭, 기존 메모리 할당 된 것이 있다면 해지 해주어야 한다. 


[예제 보기](ex/ex01.c)

## 여러개의 문자열 
* 문자열 자체가 배열이기 때문에, 여러개의 문자열을 저장하기 위해서는 이차원 배열이 필요하다. 

```
    char strings[][6] = {
        "one",
        "two",
        "three"
    };
    
    for(int i = 0; i < 3; i++) {
        printf("%s\n", strings[i]);
    }
```

>  출력 결과 

```
one
two
three
``` 

* 선언 방법은 이차원 배열과 유사하고, 스트링을 하나 씩 넣어서 초기화 해주면 된다. 
*  출력 시에는 하나의 이차원 배열 안에 하나의 값이 있기 때문에,  `strings[i]` 와 같은 형태로 하나씩 접근 할 수 있다. 
* 다만 이차원 배열 특성상, 여러 문자열이 길이가 다를 경우 가장 큰 길이를 기준으로 초기화 해주어야 한다. 
* 이를 방지하고 메모리 낭비를 줄이기 위해서는 동적 메모리 할당을 이용 해야 한다. 

## 이중 포인터
* 이차원 배열의 메모리 낭비를 막기 위해서, 이차원 배열안에 들어 가는 배열들을 동적 메모리 할당을 통해서 값을 저장 해 보려고 한다. 
* 이차원 배열을 어떻게 포인터로 표현 할 수 있을까?
* 이차원 배열은 여러개의 배열을 가지고 있다는 것을 의미한다. 
* 그말은 여러개의 동적 할당된 포인터를 가지고 있는 것을 의미하기도 한다.
* 이는 이차원 배열이, 배열 자체를 가지고 있는 것이 아니라, 여러 배열의 주소를 가지고 있는 것이다. 
* 결국 이차원 배열은 여러개의 배열과 이 배열들의 포인터를 가지고, 있는 또 다른 배열의 세트 인 것이다.
* 이 개념을 통해 아래와 같은 형태로 구현 할 수 있다.

```
char *pointerStrings[3];
    
pointerStrings[0] = (char *)malloc(sizeof(char) * 4);
strcpy(pointerStrings[0], "one");
    
pointerStrings[1] = (char *)malloc(sizeof(char) * 4);
strcpy(pointerStrings[1], "two");
    
pointerStrings[2] = (char *)malloc(sizeof(char) * 6);
strcpy(pointerStrings[2], "three");
```

`char *pointerStrings[3];`

* 3개의 문자열을 저장 하기위함 이고, 동적 메모리 할당을 이용할 것이기 때문에 char *를 3개 저장 할수 있는 배열을 선언한다. 

```
pointerStrings[0] = (char *)malloc(sizeof(char) * 4);
strcpy(pointerStrings[0], "one");
```
* char * 가 저장된 배열을 index를 통해 접근하고, 그곳에 malloc 을 통해서 동적 메모리 할당을 해준다. 
* string 특성상 (문자 갯수 + 1) 메모리를 할당 해준다. 
* strcpy 를 통해서 값을 저장 해준다. 

* 여기에서 더 나아가서 char *를 저장 하는 배열도 동적 메모리 할당을 통해서 사용이 가능하다. 

```
char **pointerStrings = (char **)malloc((sizeof(char *) * 3));
```
* 포인터의 포인터 이기 때문에 * 을 두개 붙여서 선언해준다. 
* char * 를 저장 하기 위함이기 때문에 sizeof 를 통해서  char * 의 사이즈를 얻어 온다. 
* 이와 같이 포인터의 포인터를 저장 하는 형태를 사용 하는 형태도 많이 사용 된다. 
* 이를 **이중 포인터** ,  **double pointer** 라고 한다. 

* 문자열 뿐 아니라 int 이중 포인터도 아래와 같이 사용 가능하다. 

```
int **scores = (int **)malloc(sizeof(int *) * 2);
scores[0] = (int *)malloc(sizeof(int) * 3);
scores[0][0] = 80;
scores[0][1] = 90;
scores[0][2] = 95;
    
scores[1] = (int *)malloc(sizeof(int) * 3);
scores[1][0] = 80;
scores[1][1] = 75;
scores[1][2] = 90;
    
for(int i = 0; i < 2; i++) {
    for(int j = 0; j < 3; j++) {
        printf("%d ", scores[i][j]);
    }
    printf("\n");
}
    
for(int i = 0; i < 2; i++) {
    free(scores[i]);
}
```

## 이중 포인터 해제

```
for(int i = 0; i < 3; i++) {
    free(pointerStrings[i]);
}

free(pointerStrings);
```
* malloc 을 통해서 할당된 모든 메모리는 반복문을 통해서 모두 해제 해주어야 한다. 
* 포인터의 포인터를 동적으로 할당해 주었다면 이 역시 해제해 주어야 한다. 

[예제 보기](ex/ex02.c)
